#include "AutomataMPI3D.hpp"

// ####################################################################################################################################################################
// Constructor |#######################################################################################################################################################
// ####################################################################################################################################################################
AutomataMPI3D::AutomataMPI3D(int size, int rank, unsigned long int maxCells, int randSeed, double height, double width,
                             double deep, double cellRadius, TumorParameters tumorParam) : size(size), rank(rank),
                                                                                           maxCells(maxCells),
                                                                                           nCells(0),
                                                                                           centroid(Point(0, 0, 0)),
                                                                                           randSeed(randSeed),
                                                                                           height(height), width(width),
                                                                                           deep(deep),
                                                                                           cellRadius(cellRadius),
                                                                                           tumorParam(tumorParam),
                                                                                           state0(std::vector<Cell>()),
                                                                                           state1(std::vector<Cell>()) {
    // Broadcast from master to slaves of initial attributes
    MPI_Bcast(&this->maxCells, 1, MPI_UNSIGNED_LONG, 0, MPI_COMM_WORLD);
    MPI_Bcast(&this->randSeed, 1, MPI_INT, 0, MPI_COMM_WORLD);
    MPI_Bcast(&this->height, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
    MPI_Bcast(&this->width, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
    MPI_Bcast(&this->deep, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
    MPI_Bcast(&this->cellRadius, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
    MPI_Bcast(&this->tumorParam, sizeof(TumorParameters), MPI_UNSIGNED_CHAR, 0, MPI_COMM_WORLD);

    maxAttempts = 10 * this->maxCells;
    srand(randSeed + rank);
    stateIteration = 0;
    dt = Delaunay();

    if (rank == 0) {
        allocateCellsRandomly();
        std::cout << "Cells in node 0: " << state1.size() << std::endl;
        std::cout << "Tumoral cells in node 0: " << tumorCellsIndex1.size() << std::endl;

        // Join all the cells generated by each node
        std::vector<std::vector<Cell> > nodeCells(size - 1);
        std::vector<std::vector<int> > nodeTumorCells(size - 1);
        for (int i = 1; i < size; i++) {
            int nVectorElements;

            MPI_Recv(&nVectorElements, 1, MPI_INT, i, 1, MPI_COMM_WORLD, nullptr);
            nodeCells[i - 1] = std::vector<Cell>(nVectorElements);
            std::cout << "Cells in node " << i << ": " << nVectorElements << std::endl;
            if (nVectorElements > 0) {
                MPI_Recv(&nodeCells[i - 1][0], nVectorElements * sizeof(Cell), MPI_UNSIGNED_CHAR, i, 1, MPI_COMM_WORLD,
                         nullptr);
            }

            MPI_Recv(&nVectorElements, 1, MPI_INT, i, 1, MPI_COMM_WORLD, nullptr);
            nodeTumorCells[i - 1] = std::vector<int>(nVectorElements);
            std::cout << "Tumoral cells in node " << i << ": " << nVectorElements << std::endl;
            if (nVectorElements > 0) {
                MPI_Recv(&nodeTumorCells[i - 1][0], nVectorElements, MPI_INT, i, 1, MPI_COMM_WORLD, nullptr);
            }

            for (unsigned int n = 0; n < nodeTumorCells[i - 1].size(); n++)
                nodeTumorCells[i - 1][n] += state1.size();

            state1.insert(state1.end(), nodeCells[i - 1].begin(), nodeCells[i - 1].end());
            tumorCellsIndex1.insert(tumorCellsIndex1.end(), nodeTumorCells[i - 1].begin(), nodeTumorCells[i - 1].end());
        }

        centroid.x = 0;
        centroid.y = 0;
        centroid.z = 0;
        
        for (int c: tumorCellsIndex1) {
            centroid.x += state1[c].getX();
            centroid.y += state1[c].getY();
            centroid.z += state1[c].getZ();
        }

        centroid.x /= tumorCellsIndex1.size();
        centroid.y /= tumorCellsIndex1.size();
        centroid.z /= tumorCellsIndex1.size();

        state0 = state1;
        tumorCellsIndex0 = tumorCellsIndex1;

        this->nCells = state1.size();
    } else {
        allocateCellsRandomly();

        int nVectorElements = state1.size();
        MPI_Send(&nVectorElements, 1, MPI_INT, 0, 1, MPI_COMM_WORLD);
        if (nVectorElements > 0) {
            MPI_Send(&state1[0], nVectorElements * sizeof(Cell), MPI_UNSIGNED_CHAR, 0, 1, MPI_COMM_WORLD);
        }
        nVectorElements = tumorCellsIndex1.size();
        MPI_Send(&nVectorElements, 1, MPI_INT, 0, 1, MPI_COMM_WORLD);
        if (nVectorElements > 0) {
            MPI_Send(&tumorCellsIndex1[0], nVectorElements, MPI_INT, 0, 1, MPI_COMM_WORLD);
        }
    }

    MPI_Bcast(&this->nCells, 1, MPI_UNSIGNED, 0, MPI_COMM_WORLD);
    if (rank != 0) {
        state1 = std::vector<Cell>(this->nCells);
    }
    MPI_Bcast(&state1[0], this->nCells * sizeof(Cell), MPI_UNSIGNED_CHAR, 0, MPI_COMM_WORLD);

    if (rank == 0) {
        searchNeighbors();
        updateTumorBorderCondition();

        std::cout << "Initial Tumoral Cells: " << tumorCellsIndex1.size() << std::endl;
        std::cout << "Total number of Cells: " << state1.size() << std::endl;
    } else {
        searchNeighbors();
    }

    nonInvasiveTumorCells = tumorCellsIndex1.size();
    invasiveTumorCells = 0;
}

// ####################################################################################################################################################################
// Finite States Machine of the automaton |############################################################################################################################
// ####################################################################################################################################################################
const std::vector<Cell> &AutomataMPI3D::computeNextState() {
    stateIteration++;

    state0 = state1;
    tumorCellsIndex0 = tumorCellsIndex1;

    for (unsigned int j = 0; j < tumorCellsIndex0.size(); j++) {
        unsigned int i = tumorCellsIndex0[j];

        switch (state0[i].getType()) {
            case Cell::NECROTIC:
            case Cell::ECM:
                break;
            case Cell::PROLIFERATIVE:
                ProliferationProbability res;
                proliferativeProliferates(i, res);
                if ((static_cast<double>(rand()) / RAND_MAX) < res.pDiv) {
                    state1[res.ecmCellIndex].setPECM(0.0);
                    tumorCellsIndex1.push_back(res.ecmCellIndex);    // Registers the index of every new tumoral cell
                    if ((static_cast<double>(rand()) / RAND_MAX) > tumorParam.gamma) {
                        state1[res.ecmCellIndex].setType(
                                Cell::PROLIFERATIVE);    // Update of the condition of the new proliferative cell
                        nonInvasiveTumorCells++;

                        // Centroid Update
                        centroid.x = (centroid.x * (nonInvasiveTumorCells - 1)) + state1[res.ecmCellIndex].getX();
                        centroid.y = (centroid.y * (nonInvasiveTumorCells - 1)) + state1[res.ecmCellIndex].getY();
                        centroid.z = (centroid.z * (nonInvasiveTumorCells - 1)) + state1[res.ecmCellIndex].getZ();
                        centroid.x /= nonInvasiveTumorCells;
                        centroid.y /= nonInvasiveTumorCells;
                        centroid.z /= nonInvasiveTumorCells;
                    } else {
                        state1[res.ecmCellIndex].setType(
                                Cell::INVASIVE);    // Update of the condition of the new invasive cell
                        invasiveTumorCells++;
                    }
                } else if (AutomataMPI3D::proliferativeToQuiescent(i)) {
                    state1[i].setType(Cell::QUIESCENT);
                }
                break;
            case Cell::QUIESCENT:
                if (quiescentToNectrotic(i))
                    state1[i].setType(Cell::NECROTIC);
                break;
            case Cell::INVASIVE:
                invasiveMoves(i, j);
                break;
        }
    }
    updateTumorBorderCondition();
    return state1;
}

// ####################################################################################################################################################################
// Next state functions and methods |##################################################################################################################################
// ####################################################################################################################################################################
bool AutomataMPI3D::quiescentToNectrotic(int cellIndex) {
    int nearestBoundaryIndex = 0;                                // Index of the nearest boundary cell
    double minDistance = std::numeric_limits<double>::max();    // Minimum distance from cell cellIndex and the boundary
    double Lt, deltaN;

    for (int n: tumorCellsIndex0) {
        if (state0[n].getIsBoundary() &&
            (euclideanDistance({state0[cellIndex].getX(), state0[cellIndex].getY(), state0[cellIndex].getZ()},
                               {state0[n].getX(), state0[n].getY(), state0[n].getZ()}) < minDistance)) {
            minDistance = euclideanDistance(
                    {state0[cellIndex].getX(), state0[cellIndex].getY(), state0[cellIndex].getZ()},
                    {state0[n].getX(), state0[n].getY(), state0[n].getZ()});
            nearestBoundaryIndex = n;
        }
    }

    Lt = euclideanDistance({state0[nearestBoundaryIndex].getX(), state0[nearestBoundaryIndex].getY(),
                            state0[nearestBoundaryIndex].getZ()}, centroid);

    deltaN = tumorParam.a * (pow(Lt, (double) (D - 1) / D));

    return (minDistance > deltaN);
}

bool AutomataMPI3D::proliferativeToQuiescent(int cellIndex) {
    int nearestBoundaryIndex = 0;                                // Index of the nearest boundary cell
    double minDistance = std::numeric_limits<double>::max();    // Minimum distance from cell cellIndex and the boundary
    double Lt, deltaP;

    for (int n: tumorCellsIndex0) {
        if (state0[n].getIsBoundary() &&
            (euclideanDistance({state0[cellIndex].getX(), state0[cellIndex].getY(), state0[cellIndex].getZ()},
                               {state0[n].getX(), state0[n].getY(), state0[n].getZ()}) < minDistance)) {
            minDistance = euclideanDistance(
                    {state0[cellIndex].getX(), state0[cellIndex].getY(), state0[cellIndex].getZ()},
                    {state0[n].getX(), state0[n].getY(), state0[n].getZ()});
            nearestBoundaryIndex = n;
        }
    }

    Lt = euclideanDistance({state0[nearestBoundaryIndex].getX(), state0[nearestBoundaryIndex].getY(),
                            state0[nearestBoundaryIndex].getZ()}, centroid);

    deltaP = tumorParam.b * (pow(Lt, (double) (D - 1) / D));

    return (minDistance > deltaP);
}

AutomataMPI3D::ProliferationProbability
AutomataMPI3D::proliferativeProliferates(int cellIndex, ProliferationProbability &res) {
    res.pDiv = 0;                                        // Division probability
    res.ecmCellIndex = -1;                                // Index of the nearest boundary cell
    double Lmax = std::numeric_limits<double>::max();    // Distance between the closest growth-permitting boundary cell in the direction of tumor growth and the tumor's geometric centroid
    double r = euclideanDistance({state0[cellIndex].getX(), state0[cellIndex].getY(), state0[cellIndex].getZ()},
                                 centroid);    // Distance between the proliferative cell and the tumor centroid

    if (state0[cellIndex].getIsBoundary()) {                // If isn't a tumor boundary cell, cannot proliferate, because doesn't have any ECM neighbor cell
        for (int n: state0[cellIndex].getNeighbors()) {
            if ((state0[n].getType() == Cell::ECM) &&
                (euclideanDistance({state0[n].getX(), state0[n].getY(), state0[n].getZ()}, centroid) < Lmax)) {
                Lmax = euclideanDistance({state0[n].getX(), state0[n].getY(), state0[n].getZ()}, centroid);
                res.ecmCellIndex = n;
            }
        }
        res.pDiv = (tumorParam.p0 / 2) * ((1 - (r / Lmax)) + (1 - state0[res.ecmCellIndex].getPECM()));
    }

    return res;
}

int AutomataMPI3D::invasiveMoves(int cellIndex, int vectorIndex) {
    double deltaRho;
    double bestECMCellDistance;
    int bestECMCellIndex = cellIndex;

    for (int m = 1 + (static_cast<int>(rand()) % tumorParam.muMotility); m > 0; m--) {
        deltaRho = tumorParam.xDegradation * (static_cast<double>(rand()) / RAND_MAX);
        for (int n: state0[cellIndex].getNeighbors()) {
            if (state0[n].getType() == Cell::ECM) {
                state1[n].setPECM(state0[n].getPECM() - deltaRho);
            }
        }

        bestECMCellDistance = std::numeric_limits<double>::min();
        for (int n: state1[cellIndex].getNeighbors()) {
            if ((state0[n].getType() == Cell::ECM) && (state1[n].getPECM() == 0.0) &&
                (euclideanDistance({state0[n].getX(), state0[n].getY(), state0[n].getZ()}, centroid) >
                 bestECMCellDistance)) {
                bestECMCellDistance = euclideanDistance({state0[n].getX(), state0[n].getY(), state0[n].getZ()},
                                                        centroid);
                bestECMCellIndex = n;
            }
        }
        if (bestECMCellIndex != cellIndex) {
            state1[cellIndex].setType(Cell::ECM);
            state1[bestECMCellIndex].setType(Cell::INVASIVE);
            cellIndex = bestECMCellIndex;
            tumorCellsIndex1[vectorIndex] = cellIndex;
        }
    }

    return 0;
}

// ####################################################################################################################################################################
// Tumor metrics methods |#############################################################################################################################################
// ####################################################################################################################################################################

double AutomataMPI3D::asphericity() {
    double inner = std::numeric_limits<double>::max();
    double outer = std::numeric_limits<double>::min();
    int innerCell, outerCell;

    for (int n: tumorCellsIndex1) {
        if (state1[n].getIsBoundary() &&
            (euclideanDistance({state1[n].getX(), state1[n].getY(), state1[n].getZ()}, centroid) < inner)) {
            inner = euclideanDistance({state1[n].getX(), state1[n].getY(), state1[n].getZ()}, centroid);
            innerCell = n;
        }
        if (state1[n].getIsBoundary() &&
            (euclideanDistance({state1[n].getX(), state1[n].getY(), state1[n].getZ()}, centroid) > outer)) {
            outer = euclideanDistance({state1[n].getX(), state1[n].getY(), state1[n].getZ()}, centroid);
            outerCell = n;
        }
    }

    return outer / inner;
}

// ####################################################################################################################################################################
// Auxiliar and creation/initialization methods |######################################################################################################################
// ####################################################################################################################################################################
void AutomataMPI3D::allocateCellsRandomly() {
    // Each node determines which region must fill with points
    int nNodes = size;

    if (rank < nNodes) {
        // Local parameters to the node
        maxAttempts /= nNodes;
        maxCells /= nNodes;

        double gridSize = cbrt((double) nNodes);

        double nodeWidth = width / gridSize;
        double nodeHeight = height / gridSize;
        double nodeDeep = deep / gridSize;

        double widthOffset = fmod((double) rank, gridSize) * nodeWidth;
        double heightOffset = fmod(floor((double) rank / gridSize), gridSize) * nodeHeight;
        double deepOffset = (floor((double) rank / (gridSize * gridSize))) * nodeDeep;

        // Generates random points until filling the space
        unsigned long int attempts = 0;
        Point center(width / 2, height / 2, deep / 2);
        double x, y, z;
        bool matchesCondition;
        while (attempts < maxAttempts) {
            // Generates random point inside the space
            x = widthOffset + (static_cast<double>(rand()) / RAND_MAX * nodeWidth);
            y = heightOffset + (static_cast<double>(rand()) / RAND_MAX * nodeHeight);
            z = deepOffset + (static_cast<double>(rand()) / RAND_MAX * nodeDeep);

            // Verifies if the point is at a distance greater or equal to it's
            // radius with respect to all existing points
            matchesCondition = all_of(state1.begin(), state1.end(),
                                      [&](const Cell &cell) {
                                          return euclideanDistance({x, y, z},
                                                                   {cell.getX(), cell.getY(), cell.getZ()}) >=
                                                 2 * cellRadius;
                                      });

            // Adds the point if matches the condition
            if (matchesCondition) {
                if (euclideanDistance(center, {x, y, z}) <= tumorParam.tumorInitRadius) {
                    state1.emplace_back(x, y, z, 0.0, false, Cell::PROLIFERATIVE);    // TODO: Initialize cells properly
                    state0.emplace_back(x, y, z, 0.0, false,
                                        Cell::PROLIFERATIVE);    // Both states must be initialized with the same data
                    tumorCellsIndex1.push_back(nCells);    // Registers the index of every tumoral cell
                    tumorCellsIndex0.push_back(nCells);    // Registers the index of every tumoral cell
                } else {
                    state1.emplace_back(x, y, z, 0.45);    // TODO: Initialize cells properly
                    state0.emplace_back(x, y, z, 0.45);    // Both states must be initialized with the same data
                }
                nCells++;
            }

            // Exits the loop if the desired cells number is reached
            if (state1.size() >= maxCells) {
                break;
            }

            // Increase attempts counter
            attempts++;
        }
    }
}

void AutomataMPI3D::searchNeighbors() {
    std::vector<std::vector<int> > neighbors(state1.size());
    std::vector<int> neighborsVectorsSizes(state1.size());
    unsigned long int lenght;

    // Perform Delaunay triangulation with CGAL
    std::vector<CGAL_Point> points;
    for (const Cell &cell: state1) {
        points.emplace_back(CGAL_Point(cell.getX(), cell.getY(), cell.getZ()));
    }

    dt.insert(points.begin(), points.end());

    // Find neighbors list for each point
    unsigned int pointsPerNode = points.size() / size;
    unsigned int remainigPoints = points.size() % size;
    Delaunay::Finite_vertices_iterator vBegin, vEnd;
    vBegin = dt.finite_vertices_begin();
    vEnd = dt.finite_vertices_begin();
    for (unsigned int i = 0;
         i < ((rank < remainigPoints) ? rank * (pointsPerNode + 1) : rank * pointsPerNode + remainigPoints); i++) {
        ++vBegin;
        ++vEnd;
    }
    for (unsigned int i = ((rank < remainigPoints) ? rank * (pointsPerNode + 1) : rank * pointsPerNode +
                                                                                  remainigPoints); i < ((rank <
                                                                                                         remainigPoints)
                                                                                                        ? (rank + 1) *
                                                                                                          (pointsPerNode +
                                                                                                           1) :
                                                                                                        (rank + 1) *
                                                                                                        pointsPerNode +
                                                                                                        remainigPoints); i++) {
        ++vEnd;
    }

    int cellIndex, neighbor;
    for (Delaunay::Finite_vertices_iterator v = vBegin; v != vEnd; ++v) {
        cellIndex = std::distance(points.begin(), std::find(points.begin(), points.end(),
                                                            v->point()));    // That's neccesary to find the position in the vector from the iterator
        Delaunay::Vertex_handle vh = v;

        std::vector<Delaunay::Cell_handle> adjacent_cells;
        dt.incident_cells(vh, std::back_inserter(adjacent_cells));
        for (const auto &cell: adjacent_cells) {
            for (int i = 0; i < 4; ++i) { // 4 es la dimensión de la celda en 3D
                if (cell->vertex(i) != vh) {
                    neighbor = std::distance(points.begin(),
                                             std::find(points.begin(), points.end(), cell->vertex(i)->point()));
                    if (rank == 0)
                        state1[cellIndex].getNeighbors().push_back(
                                neighbor);    // That's neccesary to find the position in the vector from the iterator
                    else
                        neighbors[cellIndex].push_back(
                                neighbor);    // That's neccesary to find the position in the vector from the iterator
                }
            }
        }
    }
    std::cout << "Node " << rank << " finished neighbors search" << std::endl;

    if (rank == 0) {
        for (int i = 1; i < size; i++) {
            MPI_Recv(&neighborsVectorsSizes[0], neighborsVectorsSizes.size(), MPI_INT, i, 1, MPI_COMM_WORLD, nullptr);
            lenght = 0;
            for (int n: neighborsVectorsSizes)
                lenght += n;

            std::cout << "Received from node " << i << " buffer size " << lenght << std::endl;
            int *buffer = new int[lenght];
            MPI_Recv(buffer, lenght, MPI_INT, i, 1, MPI_COMM_WORLD, nullptr);
            std::cout << "Received from node " << i << " buffer" << std::endl;
            deserialize(neighborsVectorsSizes, buffer);

            delete buffer;
            std::cout << "Deserialized from node " << i << std::endl;
        }
    } else {
        lenght = 0;
        for (unsigned int i = 0; i < neighbors.size(); i++) {
            neighborsVectorsSizes[i] = neighbors[i].size();
            lenght += neighborsVectorsSizes[i];
        }

        int *buffer = new int[lenght];
        serialize(neighbors, buffer);

        MPI_Send(&neighborsVectorsSizes[0], neighborsVectorsSizes.size(), MPI_INT, 0, 1, MPI_COMM_WORLD);

        MPI_Send(buffer, lenght, MPI_INT, 0, 1, MPI_COMM_WORLD);

        delete buffer;
    }
}

void AutomataMPI3D::updateTumorBorderCondition() {
    for (int n: tumorCellsIndex1) {
        if (state1[n].getType() != Cell::INVASIVE) {
            for (int i: state1[n].getNeighbors()) {    // Counts only the tumoral neighbors of the tumoral cell n
                if (state1[i].getType() == Cell::ECM) {
                    state1[n].setIsBoundary(true);
                    break;
                } else {
                    state1[n].setIsBoundary(false);
                }
            }
        }
    }
}

void AutomataMPI3D::serialize(std::vector<std::vector<int> > &neighbors, int *buffer) {
    unsigned long int index = 0;

    for (unsigned long int i = 0; i < neighbors.size(); i++) {
        for (int n: neighbors[i]) {
            buffer[index] = n;
            index++;
        }
    }
}

void AutomataMPI3D::deserialize(std::vector<int> &sizesOfEachVector, int *buffer) {
    unsigned long int index = 0;
    std::cout << "Deserializing " << std::endl;
    for (unsigned long int i = 0; i < sizesOfEachVector.size(); i++) {
        for (int j = sizesOfEachVector[i]; j > 0; j--) {
            state1[i].getNeighbors().push_back(buffer[index]);
            index++;
        }
    }
}

// ####################################################################################################################################################################
// Write files methods |###############################################################################################################################################
// ####################################################################################################################################################################
void AutomataMPI3D::storePointsToFile() {
    /*std::ofstream file("space.dat");
    for (Delaunay::Finite_vertices_iterator v = dt.finite_vertices_begin(); v != dt.finite_vertices_end(); ++v) {
        file << v->point().x() << " " << v->point().y() << std::endl;
    }
    file << "e" << std::endl;

    for (Delaunay::Finite_faces_iterator f = dt.finite_faces_begin(); f != dt.finite_faces_end(); ++f) {
        file << f->vertex(0)->point().x() << " " << f->vertex(0)->point().y() << std::endl;
        file << f->vertex(1)->point().x() << " " << f->vertex(1)->point().y() << std::endl;
        file << f->vertex(2)->point().x() << " " << f->vertex(2)->point().y() << std::endl;
        file << f->vertex(0)->point().x() << " " << f->vertex(0)->point().y() << std::endl;
        file << std::endl;
    }
    file.close();*/

#ifdef ENABLE_DRAWS
    CGAL::draw(dt);
#endif

    std::cout
            << "Command to plot with Gnuplot: plot 'space.dat' with points title 'Points', '' with lines title 'Delaunay Triangulation'"
            << std::endl;
}

void AutomataMPI3D::storeLastStateToFile() {
    std::ofstream file("state" + std::to_string(stateIteration) + ".dat");
    for (Cell c: state1) {
        if (c.getType() != Cell::ECM || c.getPECM() < 0.45) {
            file << c.getX() << " " << c.getY() << " " << c.getZ() << " ";
            switch (c.getType()) {
                case Cell::ECM:
                    file << c.getPECM() << std::endl;
                    break;
                case Cell::PROLIFERATIVE:
                    file << "5.0" << std::endl;
                    break;
                case Cell::QUIESCENT:
                    file << "2.0" << std::endl;
                    break;
                case Cell::NECROTIC:
                    file << "3.0" << std::endl;
                    break;
                case Cell::INVASIVE:
                    file << "4.0" << std::endl;
                    break;
            }
        }
    }
    file << "e" << std::endl;
    file.close();

    std::cout << "Command to plot with Gnuplot: splot 'state" << std::to_string(stateIteration)
              << ".dat' using 1:2:3:4 pt 7 ps 0.5 palette" << std::endl;
}
